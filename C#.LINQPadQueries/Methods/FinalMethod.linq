<Query Kind="Program">
  <Namespace>System.Data.Entity</Namespace>
</Query>

// Возможны два способа завершения метода - нормальное и аварийное 
// (не рассматриваем завершение процесоов, доменов приложений и потоков)
void Main()
{
	try
	{
		Devide(1,0).Dump();
	}
	catch(Exception ex)
	{
		ex.Dump();
	}
}

public static int Devide (int a, int b)
{
	int result = 0;
	
	try
	{	
		B(3);
		result = a / b;
		B(3);
	}
	catch (Exception ex)
	{
		ex.StackTrace.Dump();
		throw ex;
	}
	finally
	{
		"".Dump();
	}
	
	C();
	
	return result;
}


//  IL_0000: nop
//  IL_0001: call void UserQuery::B()
//	IL_0006: nop
//	IL_0007: ret

// нормальное завершение
// - В вызывающий метод передается типизированное возвращаемое значение  
// - CLR  гарантирует, что в параметрах, передаваемых поссылке сохраняться все изменени, 
// выполненные в теле вызываемого метода

public static void B(int a)
{
	C();
	if (a == 1)
	{
		throw new Exception();
	}
	C();
	if(a == 2) throw new ArgumentException();
}

// аврийное завершение
// - В вызывающий метод не передается типизированное возвращаемое значение  
// - CLR не гарантирует, что в параметрах, передаваемых поссылке сохраняться все изменени, 
// выполненные в теле вызываемого метода - результаты в общем случае недоступны вызывающему коду
// Альтернативный способ передачи результатов вызывающему коду - это использование объекта исключения
// исключение 


public static void C()
{

}

// Исключение вынуждает CLR изменить нормальный путь выполнения программы
// CLR ищет подходящий обработчик исключений путем просмотра стека выполняемых 
// на данный момент потоков.
// Каждый стековый фрейм содержит таблицу исключний (exception table)
// в которой расположены обработчики исключений и к каким инструкциям они применимы
// - CLR  для этого использует счетчик инструкций данного кадра стека